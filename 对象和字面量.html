<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="工具函数.js"></script>
</head>
<body>
<script>
    //在项目中我们尽量把用到的属性和方法用一个对象存起来，这样可以避免全局变量的冲突，
    //基础构造函数的原型链模式，可以有产品差异化，并且可以把共有部分共享

    function CreatePerson(name) {
        this.name = name;
    }
    //将需要共享的属性，定义到CreatePerson的原型链上，这样就可以共享给每一个类的实例
    //每一个function函数都有一个天生自带的属性prototype,但如果不new函数的话，这个属性没有任何意义
    //prototype存储的是一个对象数据类型,有一个自己的内存块，并且这个内存块上又有两个自带属性(constructor,__proto__)
    //constructor是prototype数据特有的，__proto__是所有对象数据类型都有的
    //new 出来的对象，除了拥有了函数内自带的属性和方法，还拥有了prototype上的公有属性
    //我们在调用对象上的属性的时候，先找私有的属性，没有的话才通过__proto__找原型链上的，所以私有的属性优先级比较高，原型链上都没有就报错了
    //hasOwnProperty用来检测某个实例上是否存在某个属性，但是只能检测私有的，不能检测原型链上的属性
    //每一个函数数据类型都自带prototype，但是如果不new,prototype就没有意义，他就是一个普通函数，每一个对象数据类型都自带__proto__
    //函数也是一个普通对象
    //也可以像obj一样给自己增加属性名和属性值
    //    function Person() {
    //        this.name = name;
    //        this.aa = function () {
    //            console.log('这是私有的person的方法');
    //        }
    //    }
    //    Person.prototype.gg = function () {
    //        console.log('这是person的原形链');
    //    }
    //    function Person2() {
    //        this.bb = function () {
    //            console.log('这是私有的person2的方法');
    //        }
    //    }
    //    Person2.prototype.bb2 = function () {
    //        console.log('这是person2的原型链');
    //    }
    //    function Person3() {
    //        this.cc = function () {
    //            console.log('这是私有的person3方法');
    //        }
    //    }
    //    Person3.prototype.bb3 = function () {
    //        console.log('这是person3原型链')
    //    }
    function test() {
//        this.bb = 200;
    }
    //    函数内置的一些属性:
    //prototype:函数做为类的时候可以在上面定义公有的属性和方法
    //name:'test'函数的名字
    //length:形参的个数
    //__proto__:指向Function的原型
    //Function是所有函数数据类型的基类,Object是所有对象类型的基类
    console.dir(test);
    //    var p1 = new Person();//P1拥有了person的私有方法和属性
    //    Person2.prototype = p1;//person3的原型链上获得了person的方法和属性以及person原型链上的方法和属性
    //    var p2 = new Person2();//所以当NEW一个person3实例的时候，p3就同时拥有了person的私有方法和原型链上的公有属性
    //    console.log(p2.gg());
    //    Person2.prototype.aaa = 10;//console.log(obj.aaa)输出undefined
    //    //原因在这里：应为把new Person赋值给了person2的原型链，等于就是不但把person下私有的属性都给了Person2的原型链，而且把person原型上的东西也
    //    //    给了他,所以person的prototype把person2.prototype给覆盖了，所以赋值之后，person.prototype上已经没有原来定义的属性了
    //    Person2.prototype = new Person();
    //    Person2.prototype.ddd = 30;//这里可以正常输出，应为赋值已经结束，定义的属性都可以正常存在了
    //    var obj = new Person2();
    //    obj.gg();

</script>
</body>
</html>